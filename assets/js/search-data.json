{
  
    
        "post0": {
            "title": "Temporary decline in CO2 due to COVID-19",
            "content": "Today we will work on the following graph from the article Emissions Are Surging Back as Countries and States Reopen - . . I downloaded the dataset as an Excel file and saved data for individual countries as csv files. . import altair as alt import pandas as pd . ind = pd.read_csv(&#39;ind_co2_em.csv&#39;) ind = ind.iloc[1:] chn = pd.read_csv(&#39;china_co2_em.csv&#39;, sep=&#39;;&#39;) chn = chn.iloc[1:] us = pd.read_csv(&#39;us_co2_em.csv&#39;, sep=&#39;;&#39;) us = us.iloc[1:] euuk = pd.read_csv(&#39;euuk_co2_em.csv&#39;, sep=&#39;;&#39;) euuk = euuk.iloc[1:] globl = pd.read_csv(&#39;global_co2_em.csv&#39;, sep=&#39;;&#39;) globl = globl.iloc[1:] data = pd.concat([chn, ind, euuk, us, globl]) data[&#39;DATE&#39;] = pd.to_datetime(data[&#39;DATE&#39;],format=&#39;%d/%m/%Y&#39;) data[[&#39;PWR_CO2_MED&#39;,&#39;IND_CO2_MED&#39;,&#39;TRS_CO2_MED&#39;,&#39;PUB_CO2_MED&#39;,&#39;RES_CO2_MED&#39;,&#39;AVI_CO2_MED&#39;]] = data[[&#39;PWR_CO2_MED&#39;,&#39;IND_CO2_MED&#39;,&#39;TRS_CO2_MED&#39;,&#39;PUB_CO2_MED&#39;,&#39;RES_CO2_MED&#39;,&#39;AVI_CO2_MED&#39;]].apply(pd.to_numeric) . #hide_output data.head() . If you observe the chart closely you will realize that the graph is stacked, so that is what we will do right away. . alt.Chart(data).mark_area().encode( x=alt.X(&#39;DATE:T&#39;), y=alt.Y(&#39;TOTAL_CO2_MED:Q&#39;), color=alt.Color(&#39;REGION_NAME:N&#39;),#,scale=alt.Scale(scheme=&#39;reds&#39;)), ).properties(width=800, height=400) . This is close but not exactly like what we saw in the article. If you look closely you&#39;d realize that the order of countries is different. So we will try to follow the same order using the order encoding field. . alt.Chart(data).mark_area().transform_calculate(order=&quot;{&#39;CHN&#39;: 0, &#39;IND&#39;: 1, &#39;EUandUK&#39;: 2, &#39;USA&#39;: 3, &#39;GLOBAL&#39;: 4}[datum.REGION_CODE]&quot;).encode( x=alt.X(&#39;DATE:T&#39;), y=alt.Y(&#39;TOTAL_CO2_MED:Q&#39;), color=alt.Color(&#39;REGION_CODE:N&#39;),#,scale=alt.Scale(scheme=&#39;reds&#39;)), order=&#39;order:O&#39; ).properties(width=800, height=400) . This is exactly like it. Let&#39;s change the colors, I probably would have done it the following way - . alt.Chart(data).mark_area().transform_calculate(order=&quot;{&#39;CHN&#39;: 0, &#39;IND&#39;: 1, &#39;EUandUK&#39;: 2, &#39;USA&#39;: 3, &#39;GLOBAL&#39;: 4}[datum.REGION_CODE]&quot;).encode( x=alt.X(&#39;DATE:T&#39;), y=alt.Y(&#39;TOTAL_CO2_MED:Q&#39;), color=alt.Color(&#39;REGION_CODE:N&#39;,scale=alt.Scale(domain=[&#39;CHN&#39;, &#39;IND&#39;, &#39;EUandUK&#39;, &#39;USA&#39;, &#39;GLOBAL&#39;], range=[&quot;#c9c9c9&quot;, &quot;#aaaaaa&quot;, &quot;#888888&quot;, &quot;#686868&quot;, &quot;#454545&quot;])), order=&#39;order:O&#39; ).properties(width=800, height=400) . To make it just like the graph in the article, we will pick colors from here https://imagecolorpicker.com/en/ . alt.Chart(data).mark_area().transform_calculate(order=&quot;{&#39;CHN&#39;: 0, &#39;IND&#39;: 1, &#39;EUandUK&#39;: 2, &#39;USA&#39;: 3, &#39;GLOBAL&#39;: 4}[datum.REGION_CODE]&quot;).encode( x=alt.X(&#39;DATE:T&#39;), y=alt.Y(&#39;TOTAL_CO2_MED:Q&#39;), color=alt.Color(&#39;REGION_CODE:N&#39;,scale=alt.Scale(domain=[&#39;CHN&#39;, &#39;IND&#39;, &#39;EUandUK&#39;, &#39;USA&#39;, &#39;GLOBAL&#39;], range=[&quot;#fde9d1&quot;, &quot;#fcd08b&quot;, &quot;#f9b382&quot;, &quot;#e38875&quot;, &quot;#ac7066&quot;])), order=&#39;order:O&#39; ).properties(width=800, height=400) . If you look closely, you would notice that we are capturing the trend perfectly, however the area for &quot;REST of the world&quot; is much more than what it should be. That is because, its duplicating the data from US, EU, India, and China. So we need to subtract the contributions of these places from the global data and then stack them. . chn[&#39;DATE&#39;] = pd.to_datetime(chn[&#39;DATE&#39;],format=&#39;%d/%m/%Y&#39;) ind[&#39;DATE&#39;] = pd.to_datetime(ind[&#39;DATE&#39;],format=&#39;%d/%m/%Y&#39;) us[&#39;DATE&#39;] = pd.to_datetime(us[&#39;DATE&#39;],format=&#39;%d/%m/%Y&#39;) euuk[&#39;DATE&#39;] = pd.to_datetime(euuk[&#39;DATE&#39;],format=&#39;%d/%m/%Y&#39;) globl[&#39;DATE&#39;] = pd.to_datetime(globl[&#39;DATE&#39;],format=&#39;%d/%m/%Y&#39;) . ind[list(ind.columns)[5:]] = ind[list(ind.columns)[5:]].apply(pd.to_numeric) chn[list(chn.columns)[5:]] = chn[list(chn.columns)[5:]].apply(pd.to_numeric) us[list(us.columns)[5:]] = us[list(us.columns)[5:]].apply(pd.to_numeric) euuk[list(euuk.columns)[5:]] = euuk[list(euuk.columns)[5:]].apply(pd.to_numeric) globl[list(globl.columns)[5:]] = globl[list(globl.columns)[5:]].apply(pd.to_numeric) . countries_sum = ind[list(ind.columns)[5:]]+chn[list(chn.columns)[5:]]+us[list(us.columns)[5:]]+euuk[list(euuk.columns)[5:]] . rest = globl[list(globl.columns)[5:]] - countries_sum[list(countries_sum.columns)] . rest[&#39;REGION_ID&#39;] = 99 rest[&#39;REGION_CODE&#39;] = &#39;RST&#39; rest[&#39;REGION_NAME&#39;] = &#39;REST&#39; rest[&#39;TIME_POINT&#39;] = globl[&#39;TIME_POINT&#39;] rest[&#39;DATE&#39;] = globl[&#39;DATE&#39;] . data = pd.concat([chn, ind, euuk, us, rest]) . alt.Chart(data).mark_area().transform_calculate(order=&quot;{&#39;CHN&#39;: 0, &#39;IND&#39;: 1, &#39;EUandUK&#39;: 2, &#39;USA&#39;: 3, &#39;RST&#39;: 4}[datum.REGION_CODE]&quot;).encode( x=alt.X(&#39;DATE:T&#39;, axis=alt.Axis(format=(&quot;%B&quot;))), y=alt.Y(&#39;TOTAL_CO2_MED:Q&#39;), color=alt.Color(&#39;REGION_CODE:N&#39;,scale=alt.Scale(domain=[&#39;CHN&#39;, &#39;IND&#39;, &#39;EUandUK&#39;, &#39;USA&#39;, &#39;RST&#39;], range=[&quot;#fde9d1&quot;, &quot;#fcd08b&quot;, &quot;#f9b382&quot;, &quot;#e38875&quot;, &quot;#ac7066&quot;])), order=&#39;order:O&#39; ).properties(width=800, height=400).configure_view(strokeWidth=0).configure_axis(grid=False) . base = alt.Chart(data).mark_area().transform_calculate(order=&quot;{&#39;CHN&#39;: 0, &#39;IND&#39;: 1, &#39;EUandUK&#39;: 2, &#39;USA&#39;: 3, &#39;RST&#39;: 4}[datum.REGION_CODE]&quot;).encode( x=alt.X(&#39;DATE:T&#39;, axis=alt.Axis(format=(&quot;%B&quot;))), y=alt.Y(&#39;TOTAL_CO2_MED:Q&#39;), color=alt.Color(&#39;REGION_CODE:N&#39;,scale=alt.Scale(domain=[&#39;CHN&#39;, &#39;IND&#39;, &#39;EUandUK&#39;, &#39;USA&#39;, &#39;RST&#39;], range=[&quot;#fde9d1&quot;, &quot;#fcd08b&quot;, &quot;#f9b382&quot;, &quot;#e38875&quot;, &quot;#ac7066&quot;])), order=&#39;order:O&#39; ).properties(width=800, height=400) t = alt.Chart(data).mark_text().encode( x=alt.X(&#39;DATE:T&#39;, aggregate=&#39;median&#39;, ), #y=alt.Y(&#39;variety:N&#39;), #detail=&#39;REGION_CODE:N&#39;, text=alt.Text(&#39;REGION_NAME:N&#39;), y=&#39;min(TOTAL_CO2_MED):Q&#39;, #text=&#39;REGION_NAME:N&#39; ) (base+t).configure_view(strokeWidth=0).configure_axis(grid=False) . While we are at it we can also make the following graph of global emissions by sector - . . line = alt.Chart(globl).mark_line().encode( x=&#39;DATE:T&#39;, y=alt.Y(&#39;TRS_CO2_MED:Q&#39;), ) band = line.mark_area(opacity=0.3).encode( x=&#39;DATE:T&#39;, y=alt.Y(&#39;TRS_CO2_LOW:Q&#39;), y2=alt.Y2(&#39;TRS_CO2_HIGH:Q&#39;), ) line+band . l = alt.Chart(globl).mark_line().transform_fold([&#39;TRS_CO2_MED&#39;, &#39;IND_CO2_MED&#39;, &#39;PWR_CO2_MED&#39;, &#39;PUB_CO2_MED&#39;, &#39;AVI_CO2_MED&#39;, &#39;RES_CO2_MED&#39;]).encode( x=&#39;DATE:T&#39;, y=&#39;value:Q&#39;, ).facet( &#39;key:N&#39;,columns=3 ) l .",
            "url": "https://armsp.github.io/covidviz/climate/2020/06/26/CO2-Emissions.html",
            "relUrl": "/climate/2020/06/26/CO2-Emissions.html",
            "date": " • Jun 26, 2020"
        }
        
    
  
    
        ,"post1": {
            "title": "World Geospatial chloropleth plot of cases",
            "content": "Today we will make a chloropleth of the countries in a world map like in the article Coronavirus Map: Tracking the Global Outbreak that looks like this - . For this we will use the JHU CSSE Dataset . #hide_output import pandas as pd import geopandas as gpd import altair as alt import numpy as np alt.renderers.set_embed_options(actions=False) . I made the following geojson file from the US State Department Global LSIB Polygons Detailes after simplifying it as it has too much details and is very large. Following is the code to do that. . Warning: Do NOT RUN THE FOLLOWING CELL. USe the geojson file I have provided - run the cell following the following cell. . #collapse us_st_world = gpd.read_file(&#39;shapes/Global_LSIB_Polygons_Detailed/Global_LSIB_Polygons_Detailed.dbf&#39;) us_st_world.drop([&#39;OBJECTID&#39;, &#39;Shape_Leng&#39;, &#39;Shape_Le_1&#39;, &#39;Shape_Area&#39;], axis=1, inplace=True) us_st_world[&quot;geometry&quot;] = us_st_world.geometry.simplify(tolerance=0.05) us_st_world.to_file(&quot;world.geojson&quot;, driver=&#39;GeoJSON&#39;) #alt.Chart(us_st_world_).mark_geoshape(strokeWidth=1, stroke=&#39;white&#39;).encode().properties(width=1000, height=500).project(&#39;equalEarth&#39;) . . world_geojson = &#39;https://raw.githubusercontent.com/armsp/covidviz/master/assets/world.geojson&#39; us_st_world = gpd.read_file(world_geojson) . uri = &#39;https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv&#39; time_s_raw = pd.read_csv(uri) time_s = time_s_raw.groupby(&#39;Country/Region&#39;).agg(dict(zip(time_s_raw.columns[4:], [&#39;sum&#39;]*(len(time_s_raw.columns)-4)))) time_s = time_s.reset_index() #time_s . Let&#39;s first find out what countries in our dataset are not present in the shapefile . time_s[time_s[&#39;Country/Region&#39;].isin(us_st_world[&#39;COUNTRY_NA&#39;]) == False] . Country/Region 1/22/20 1/23/20 1/24/20 1/25/20 1/26/20 1/27/20 1/28/20 1/29/20 1/30/20 ... 6/10/20 6/11/20 6/12/20 6/13/20 6/14/20 6/15/20 6/16/20 6/17/20 6/18/20 6/19/20 . 5 Antigua and Barbuda | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 26 | 26 | 26 | 26 | 26 | 26 | 26 | 26 | 26 | 26 | . 11 Bahamas | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 103 | 103 | 103 | 103 | 103 | 103 | 104 | 104 | 104 | 104 | . 21 Bosnia and Herzegovina | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 2775 | 2832 | 2893 | 2893 | 2893 | 3040 | 3085 | 3141 | 3174 | 3273 | . 33 Central African Republic | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 1888 | 1952 | 2044 | 2057 | 2057 | 2222 | 2410 | 2564 | 2605 | 2605 | . 39 Congo (Brazzaville) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 728 | 728 | 728 | 728 | 728 | 883 | 883 | 883 | 883 | 883 | . 40 Congo (Kinshasa) | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 4390 | 4515 | 4637 | 4724 | 4778 | 4837 | 4974 | 5100 | 5283 | 5477 | . 48 Diamond Princess | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 712 | 712 | 712 | 712 | 712 | 712 | 712 | 712 | 712 | 712 | . 58 Eswatini | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 398 | 449 | 472 | 486 | 490 | 506 | 520 | 563 | 586 | 623 | . 64 Gambia | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 28 | 28 | 28 | 28 | 28 | 30 | 34 | 34 | 36 | 36 | . 75 Holy See | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | . 104 MS Zaandam | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | . 127 North Macedonia | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 3364 | 3538 | 3701 | 3895 | 4057 | 4157 | 4299 | 4482 | 4664 | 4820 | . 142 Saint Kitts and Nevis | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 15 | 15 | 15 | 15 | 15 | 15 | 15 | 15 | 15 | 15 | . 143 Saint Lucia | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 19 | 19 | 19 | 19 | 19 | 19 | 19 | 19 | 19 | 19 | . 144 Saint Vincent and the Grenadines | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 27 | 27 | 27 | 27 | 27 | 27 | 29 | 29 | 29 | 29 | . 146 Sao Tome and Principe | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 611 | 632 | 639 | 659 | 661 | 662 | 671 | 683 | 688 | 693 | . 165 Taiwan* | 1 | 1 | 3 | 3 | 4 | 5 | 8 | 8 | 9 | ... | 443 | 443 | 443 | 443 | 443 | 445 | 445 | 445 | 446 | 446 | . 171 Trinidad and Tobago | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 117 | 117 | 117 | 117 | 123 | 123 | 123 | 123 | 123 | 123 | . 174 US | 1 | 1 | 2 | 2 | 5 | 5 | 5 | 5 | 5 | ... | 2000702 | 2023590 | 2048986 | 2074526 | 2094058 | 2114026 | 2137731 | 2163290 | 2191052 | 2220961 | . 183 West Bank and Gaza | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 485 | 487 | 489 | 489 | 492 | 505 | 514 | 555 | 600 | 675 | . 184 Western Sahara | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | . 21 rows × 151 columns . Now we need to understand that the monikers of the countries can change and that we need to figure out how to unify them and then merge them. For that let&#39;s study each of the missing countries one by one like so - . #hide_output us_st_world[us_st_world[&#39;COUNTRY_NA&#39;].str.startswith(&#39;Antigua&#39;)] . Do the same technique for all the contries and you&#39;d end up with the following modifications - . time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Taiwan*&#39;, &#39;Country/Region&#39;] = &#39;Taiwan&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;US&#39;, &#39;Country/Region&#39;] = &#39;United States&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Czech Republic&#39;, &#39;Country/Region&#39;] = &#39;Czechia&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;West Bank and Gaza&#39;, &#39;Country/Region&#39;] = &#39;West Bank (disp)&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Western Sahara&#39;, &#39;Country/Region&#39;] = &#39;Western Sahara (disp)&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Trinidad and Tobago&#39;, &#39;Country/Region&#39;] = &#39;Trinidad &amp; Tobago&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Sao Tome and Principe&#39;, &#39;Country/Region&#39;] = &#39;Sao Tome &amp; Principe&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Saint Vincent and the Grenadines&#39;, &#39;Country/Region&#39;] = &#39;St Vincent &amp; the Grenadines&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Saint Lucia&#39;, &#39;Country/Region&#39;] = &#39;St Lucia&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Saint Kitts and Nevis&#39;, &#39;Country/Region&#39;] = &#39;St Kitts &amp; Nevis&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;North Macedonia&#39;, &#39;Country/Region&#39;] = &#39;Macedonia&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Bahamas&#39;, &#39;Country/Region&#39;] = &#39;Bahamas, The&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Bosnia and Herzegovina&#39;, &#39;Country/Region&#39;] = &#39;Bosnia &amp; Herzegovina&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Central African Republic&#39;, &#39;Country/Region&#39;] = &#39;Central African Rep&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Eswatini&#39;, &#39;Country/Region&#39;] = &#39;Swaziland&#39; #time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;South Korea&#39;, &#39;Country/Region&#39;] = &#39;Korea, South&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Congo (Kinshasa)&#39;, &#39;Country/Region&#39;] = &#39;Congo, Dem Rep of the&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Congo (Brazzaville)&#39;, &#39;Country/Region&#39;] = &#39;Congo, Rep of the&#39; time_s.loc[time_s[&#39;Country/Region&#39;]==&#39;Antigua and Barbuda&#39;, &#39;Country/Region&#39;] = &#39;Antigua &amp; Barbuda&#39; . TODO . Can we do the above using code instead of manually? . We will ignore the following due to very few cases . # collapse time_s[time_s[&#39;Country/Region&#39;].isin(us_st_world[&#39;COUNTRY_NA&#39;]) == False] . . Country/Region 1/22/20 1/23/20 1/24/20 1/25/20 1/26/20 1/27/20 1/28/20 1/29/20 1/30/20 ... 6/10/20 6/11/20 6/12/20 6/13/20 6/14/20 6/15/20 6/16/20 6/17/20 6/18/20 6/19/20 . 48 Diamond Princess | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 712 | 712 | 712 | 712 | 712 | 712 | 712 | 712 | 712 | 712 | . 64 Gambia | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 28 | 28 | 28 | 28 | 28 | 30 | 34 | 34 | 36 | 36 | . 75 Holy See | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | 12 | . 104 MS Zaandam | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | ... | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | 9 | . 4 rows × 151 columns . Finding cases per day - . time_s_T = time_s.set_index(&#39;Country/Region&#39;).T time_s_T = time_s_T.apply(lambda x: x.diff(), axis=0) . Averageing the cases over a week - . # hide_output roll_case_avg_list = [] def roll_case_avg(row): #print(row) avgs = row[::-1].rolling(window=7).mean().apply(np.floor).shift(-6) roll_case_avg_list.append((row.name, avgs.iloc[0], avgs.iloc[14])) #print(avgs.iloc[1], avgs.iloc[8]) p = time_s_T.T p.apply(roll_case_avg, axis=1) . #roll_case_avg_list . I asked the NYT GitHub Team on how they are establishing the category colors and based on their input we will use the following classification - . The thresholds for that change are: . Blue: &lt; -15% | Yellow: &gt; -15% and &lt; +15% | Light orange: &gt;+15% and &lt;+100% | Mid orange: &gt;+100% and &lt;+200% | Dark red: &gt;+200% | . Let&#39;s define a function to do that for us - . def categorize(x): if x[&#39;now&#39;] == 0 or x[&#39;ago&#39;] == 0:#x[&#39;ago&#39;] &lt;= 5 or return &#39;Few or no cases&#39; delta = x[&#39;diff&#39;]/x[&#39;ago&#39;]*100 if delta &lt; -15: return &#39;Declining&#39; elif delta &gt; -15 and delta &lt; 15: return &#39;About the same&#39; elif delta &gt; 15 and delta &lt; 100: return &#39;Growth upto 2x&#39; elif delta &gt; 100 and delta &lt; 200: return &#39;Growth upto 3x&#39; elif delta &gt; 200: return &#39;Growth more than 3x&#39; . test2 = pd.DataFrame(roll_case_avg_list, columns=[&#39;country&#39;,&#39;now&#39;,&#39;ago&#39;]) test2[&#39;diff&#39;] = test2[&#39;now&#39;] - test2[&#39;ago&#39;] test2[&#39;category&#39;] = test2.apply(categorize, axis=1) test2.groupby(&#39;category&#39;).count() . country now ago diff . category . About the same 27 | 27 | 27 | 27 | . Declining 35 | 35 | 35 | 35 | . Few or no cases 48 | 48 | 48 | 48 | . Growth more than 3x 11 | 11 | 11 | 11 | . Growth upto 2x 51 | 51 | 51 | 51 | . Growth upto 3x 14 | 14 | 14 | 14 | . test2.columns = [&#39;COUNTRY_NA&#39;, &#39;now&#39;, &#39;ago&#39;, &#39;diff&#39;, &#39;category&#39;] plot2 = us_st_world.merge(test2, how=&#39;left&#39;, on=&#39;COUNTRY_NA&#39;) . plot2 . COUNTRY_NA geometry now ago diff category . 0 Abyei (disp) | POLYGON ((29.00000 9.67356, 28.78724 9.49406, ... | NaN | NaN | NaN | NaN | . 1 Afghanistan | POLYGON ((70.98955 38.49070, 71.37353 38.25597... | 618.0 | 758.0 | -140.0 | Declining | . 2 Akrotiri (UK) | POLYGON ((32.83539 34.70576, 32.98961 34.67999... | NaN | NaN | NaN | NaN | . 3 Aksai Chin (disp) | MULTIPOLYGON (((78.69853 34.09310, 78.69837 34... | NaN | NaN | NaN | NaN | . 4 Albania | POLYGON ((19.72764 42.66045, 19.79268 42.48135... | 60.0 | 16.0 | 44.0 | Growth more than 3x | . ... ... | ... | ... | ... | ... | ... | . 274 Burma | MULTIPOLYGON (((98.03206 9.83411, 98.06033 9.8... | 3.0 | 4.0 | -1.0 | Declining | . 275 India | MULTIPOLYGON (((93.84583 7.24456, 93.96289 7.0... | 12293.0 | 8956.0 | 3337.0 | Growth upto 2x | . 276 Benin | POLYGON ((2.84088 12.40599, 3.26927 12.01606, ... | 37.0 | 5.0 | 32.0 | Growth more than 3x | . 277 Niger | POLYGON ((12.02686 23.50849, 13.52600 23.15616... | 6.0 | 1.0 | 5.0 | Growth more than 3x | . 278 Nigeria | MULTIPOLYGON (((6.13707 4.37177, 6.08799 4.359... | 566.0 | 363.0 | 203.0 | Growth upto 2x | . 279 rows × 6 columns . Now we are ready to plot the chloropleth - . # collapse base=alt.Chart(plot2).mark_geoshape(stroke=&#39;white&#39;).transform_filter((alt.datum.COUNTRY_NA != &#39;Antarctica&#39;)).encode( color = alt.Color(&#39;category:N&#39;, scale=alt.Scale( domain=[&#39;Few or no cases&#39;, &#39;Declining&#39;, &#39;About the same&#39;, &#39;Growth upto 2x&#39;, &#39;Growth upto 3x&#39;, &#39;Growth more than 3x&#39;], range=[&#39;#f2f2f2&#39;, &#39;#badee8&#39;, &#39;#f2df91&#39;, &#39;#ffae43&#39;, &#39;#ff6e0b&#39;, &#39;#ce0a05&#39;] ), legend=alt.Legend(title=None, orient=&#39;top&#39;, labelBaseline=&#39;middle&#39;, symbolType=&#39;square&#39;, columnPadding=20, labelFontSize=15, gridAlign=&#39;each&#39;, symbolSize=200) ), tooltip = [&#39;COUNTRY_NA&#39;, alt.Tooltip(&#39;now:Q&#39;, format=&#39;.0d&#39;), alt.Tooltip(&#39;ago:Q&#39;, format=&#39;.0d&#39;), &#39;category&#39;] ).properties(height=800, width=1500).project(&#39;equalEarth&#39;).configure_view(strokeWidth=0) . . base . We can do something even more interesting...we can make the chart interactive by highlighting the countries based on their category - . Falling | Almost the same | Rising 1 | Rising 2 | Rising 3. | . #collapse selector = alt.selection_single( fields=[&#39;category&#39;], empty=&#39;all&#39;, bind=&#39;legend&#39; ) interactive = base.encode( color = alt.Color( &#39;category:N&#39;, legend=alt.Legend(values=[&#39;Declining&#39;, &#39;About the same&#39;, &#39;Growth upto 2x&#39;, &#39;Growth upto 3x&#39;, &#39;Growth more than 3x&#39;], title=None, orient=&#39;top&#39;, labelBaseline=&#39;middle&#39;, symbolType=&#39;square&#39;, columnPadding=20, labelFontSize=15, gridAlign=&#39;each&#39;, symbolSize=200), scale=alt.Scale( domain=[&#39;Few or no cases&#39;, &#39;Declining&#39;, &#39;About the same&#39;, &#39;Growth upto 2x&#39;, &#39;Growth upto 3x&#39;, &#39;Growth more than 3x&#39;], range=[&#39;#f2f2f2&#39;, &#39;#badee8&#39;, &#39;#f2df91&#39;, &#39;#ffae43&#39;, &#39;#ff6e0b&#39;, &#39;#ce0a05&#39;] ) ), opacity=alt.condition(selector, alt.value(1), alt.value(0.25)) ).add_selection( selector ) . . Now click on the legend to highlight the countries for that category. . interactive .",
            "url": "https://armsp.github.io/covidviz/geospatial/2020/06/15/World-Case-per-day-chloropleth.html",
            "relUrl": "/geospatial/2020/06/15/World-Case-per-day-chloropleth.html",
            "date": " • Jun 15, 2020"
        }
        
    
  
    
        ,"post2": {
            "title": "Geospatial plot of cases in US",
            "content": "Today we will make our first geospatial map from the article Coronavirus in the U.S.: Latest Map and Case Count which looks like the folowing - . import geopandas as gpd import altair as alt import pandas as pd alt.renderers.set_embed_options(actions=False) # Shapefiles from us census state_shpfile = &#39;./shapes/cb_2019_us_state_20m&#39; county_shpfile = &#39;./shapes/cb_2019_us_county_20m&#39; states = gpd.read_file(state_shpfile) county = gpd.read_file(county_shpfile) # Adding longitude and latitude in state data states[&#39;lon&#39;] = states[&#39;geometry&#39;].centroid.x states[&#39;lat&#39;] = states[&#39;geometry&#39;].centroid.y # Adding longitude and latitude in state data county[&#39;lon&#39;] = county[&#39;geometry&#39;].centroid.x county[&#39;lat&#39;] = county[&#39;geometry&#39;].centroid.y . # NYT dataset county_url = &#39;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv&#39; cdf = pd.read_csv(county_url) . cdf[cdf[&#39;fips&#39;].isnull() == True].groupby([&#39;county&#39;]).sum() . fips cases deaths . county . Kansas City 0.0 | 56244 | 1244 | . New York City 0.0 | 12364882 | 1202577 | . Unknown 0.0 | 802914 | 32423 | . #hide_output cdf[cdf[&#39;fips&#39;].isnull() == True].groupby([&#39;county&#39;, &#39;state&#39;]).sum() . # collapse latest_cases = cdf.groupby(&#39;county&#39;, as_index=False).agg({&#39;date&#39;: &#39;last&#39;, &#39;state&#39;: &#39;last&#39;, &#39;fips&#39;: &#39;last&#39;, &#39;cases&#39;: &#39;last&#39;, &#39;deaths&#39;: &#39;last&#39;}) latest_cases . . county date state fips cases deaths . 0 Abbeville | 2020-06-12 | South Carolina | 45001.0 | 62 | 0 | . 1 Acadia | 2020-06-12 | Louisiana | 22001.0 | 535 | 31 | . 2 Accomack | 2020-06-12 | Virginia | 51001.0 | 987 | 13 | . 3 Ada | 2020-06-12 | Idaho | 16001.0 | 877 | 22 | . 4 Adair | 2020-06-12 | Oklahoma | 40001.0 | 95 | 4 | . ... ... | ... | ... | ... | ... | ... | . 1777 Yukon-Koyukuk Census Area | 2020-06-12 | Alaska | 2290.0 | 1 | 0 | . 1778 Yuma | 2020-06-12 | Colorado | 8125.0 | 47 | 0 | . 1779 Zapata | 2020-06-12 | Texas | 48505.0 | 14 | 0 | . 1780 Zavala | 2020-06-12 | Texas | 48507.0 | 12 | 0 | . 1781 Ziebach | 2020-06-12 | South Dakota | 46137.0 | 2 | 0 | . 1782 rows × 6 columns . NYT publishes the data for New York City in a different way by combining the results of the 5 boroughs that comprise it. So we will combine them too and add a new row in the dataset with a custom fips of 1. But first we need to dissolve the 5 buroughs into one single geospatial entity. . #New York City fips = 36005&#39;, &#39;36047&#39;, &#39;36061&#39;, &#39;36081&#39;, &#39;36085 which corresponds to New York, Kings, Queens, Bronx and Richmond spatial_nyc = county[county[&#39;GEOID&#39;].isin([&#39;36005&#39;, &#39;36047&#39;, &#39;36061&#39;, &#39;36081&#39;, &#39;36085&#39;])] . combined_nyc = spatial_nyc.dissolve(by=&#39;STATEFP&#39;) alt.Chart(spatial_nyc).mark_geoshape(stroke=&#39;white&#39;, strokeWidth=3).encode() | alt.Chart(combined_nyc).mark_geoshape(stroke=&#39;white&#39;, strokeWidth=3).encode() . agg_nyc_data = spatial_nyc.dissolve(by=&#39;STATEFP&#39;).reset_index() agg_nyc_data[&#39;GEOID&#39;] = &#39;1&#39; agg_nyc_data[&#39;fips&#39;] = 1 agg_nyc_data[&#39;lon&#39;] = agg_nyc_data[&#39;geometry&#39;].centroid.x agg_nyc_data[&#39;lat&#39;] = agg_nyc_data[&#39;geometry&#39;].centroid.y . agg_nyc_data . STATEFP geometry COUNTYFP COUNTYNS AFFGEOID GEOID NAME LSAD ALAND AWATER lon lat fips . 0 36 | POLYGON ((-74.24921 40.54506, -74.21684 40.558... | 061 | 00974129 | 0500000US36061 | 1 | New York | 06 | 58690498 | 28541727 | -73.927011 | 40.695278 | 1 | . # hide_output county_nyc = gpd.GeoDataFrame(pd.concat([county, agg_nyc_data], ignore_index=True)) county_nyc[&#39;fips&#39;] = county_nyc[&#39;GEOID&#39;] county_nyc[&#39;fips&#39;] = county_nyc[&#39;fips&#39;].astype(&#39;int&#39;) county_nyc # generate FIPS in the shapefile itself by combining STATEFP and COUNTYFP #county2[&#39;STATEFP&#39;] + county2[&#39;COUNTYFP&#39;] #latest_cases[&#39;fips&#39;] = latest_cases[&#39;fips&#39;].astype(&#39;int&#39;) . latest_cases[&#39;fips&#39;].isin(county_nyc[&#39;fips&#39;]).value_counts() . True 1779 False 3 Name: fips, dtype: int64 . latest_cases.loc[latest_cases[&#39;county&#39;] == &#39;New York City&#39;,&#39;fips&#39;] = 1 latest_cases[latest_cases[&#39;county&#39;] == &#39;New York City&#39;] . county date state fips cases deaths . 1125 New York City | 2020-06-12 | New York | 1.0 | 213707 | 21519 | . latest_cases[latest_cases[&#39;fips&#39;] == 1] . county date state fips cases deaths . 1125 New York City | 2020-06-12 | New York | 1.0 | 213707 | 21519 | . county_nyc[county_nyc[&#39;fips&#39;] == 1] . STATEFP COUNTYFP COUNTYNS AFFGEOID GEOID NAME LSAD ALAND AWATER geometry lon lat fips . 3220 36 | 061 | 00974129 | 0500000US36061 | 1 | New York | 06 | 58690498 | 28541727 | POLYGON ((-74.24921 40.54506, -74.21684 40.558... | -73.927011 | 40.695278 | 1 | . # collapse latest_cases_w_fips = county_nyc.merge(latest_cases, how=&#39;left&#39;, on=&#39;fips&#39;) circle_selection = alt.selection_single(on=&#39;mouseover&#39;, empty=&#39;none&#39;) circles = alt.Chart(latest_cases_w_fips).mark_point(fillOpacity=0.2, fill=&#39;red&#39;, strokeOpacity=1, color=&#39;red&#39;, strokeWidth=1).encode( latitude=&quot;lat:Q&quot;, longitude=&quot;lon:Q&quot;, size=alt.Size(&#39;cases:Q&#39;, scale=alt.Scale(domain=[0, 7000],),legend=alt.Legend(title=&quot;Cases&quot;)), tooltip=[&#39;county:N&#39;, &#39;cases:Q&#39;, &#39;deaths:Q&#39;], color = alt.condition(circle_selection, alt.value(&#39;black&#39;), alt.value(&#39;red&#39;)) ).project( type=&#39;albersUsa&#39; ).properties( width=800, height=550 ).add_selection( circle_selection ) state = alt.Chart(states).mark_geoshape(fill=&#39;#ededed&#39;, stroke=&#39;white&#39;).encode( ).project( type=&#39;albersUsa&#39; ) state_text = state.mark_text().transform_filter(alt.datum.NAME != &#39;Puerto Rico&#39;).encode( longitude=&#39;lon:Q&#39;, latitude=&#39;lat:Q&#39;, text=&#39;NAME&#39;, ).project( type=&#39;albersUsa&#39; ) . . (state+circles+state_text).configure_view(strokeWidth=0) .",
            "url": "https://armsp.github.io/covidviz/geospatial/2020/06/12/US-case-counts-geospatial.html",
            "relUrl": "/geospatial/2020/06/12/US-case-counts-geospatial.html",
            "date": " • Jun 12, 2020"
        }
        
    
  
    
        ,"post3": {
            "title": "Deaths above or below normal",
            "content": "We will make charts from the NYT article on What Is the Real Coronavirus Death Toll in Each State? . The charts look like the following - . Whats the purpose of this visualization? . Comparing recent totals of deaths from all causes can provide a more complete picture of the pandemic’s impact than tracking only deaths of people with confirmed diagnoses. Epidemiologists refer to fatalities in the gap between the observed and normal numbers of deaths as “excess deaths.” . Indeed, in nearly every state with an unusual number of deaths in recent weeks, that number is higher than the state’s reported number of deaths from Covid-19. On our charts, we have marked the number of official coronavirus deaths with red lines, so you can see how they match up with the total number of excess deaths. . Measuring excess deaths is crude because it does not capture all the details of how people died. But many epidemiologists believe it is the best way to measure the impact of the virus in real time. It shows how the virus is altering normal patterns of mortality where it strikes and undermines arguments that it is merely killing vulnerable people who would have died anyway. . Public health researchers use such methods to measure the impact of catastrophic events when official measures of mortality are flawed. . Measuring excess deaths does not tell us precisely how each person died. It is likely that most of the excess deaths in this period are because of the coronavirus itself, given the dangerousness of the virus and the well-documented problems with testing. But it is also possible that deaths from other causes have risen too, as hospitals have become stressed and people have been scared to seek care for ailments that are typically survivable. Some causes of death may be declining, as people stay inside more, drive less and limit their contact with others. . We will use 2 datasets to generate our chart - . The excess deaths dataset from NYT | The COVID-19 deaths dataset also from NYT | Luckily both are in the same GitHub repository - NYT Covid-19 Data However we need to do some significant preprocessing to arrive at the results. It took me a good amount of time to figure out the whole graph and once I had done it it just made so much sense :relieved: . The way these graphs are made is as follows - . First we chart the excess deaths. Excess deaths is calculated as the difference b/w all cause mortality data with expected deaths. These data are available from CDC. | NYT publishes the excess deaths data for NYC, so for starters we will use that before moving on to the other states. | Then we need to get the covid-19 related deaths from NYC which we can get from the NYT dataset or JHU CSSE dataset. | The challenge is actually combining the above. | How do we combine the above data? . The excess deaths data is weekly. With the starting and ending dates given (7 days duration), so what we are gonna do is we have to transform the COVID-19 deaths data in the same weekly format. . import pandas as pd import numpy as np import altair as alt excess_uri = &#39;https://raw.githubusercontent.com/nytimes/covid-19-data/master/excess-deaths/deaths.csv&#39; county_uri = &#39;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-counties.csv&#39; ex_df = pd.read_csv(excess_uri) co_df = pd.read_csv(county_uri) . Extracting data for NYC for year 2020 - . # collapse_show ex_nyc = ex_df[(ex_df[&#39;placename&#39;] == &#39;New York City&#39;)] ex_nyc[&#39;year&#39;] = ex_nyc[&#39;year&#39;].astype(int) ex_nyc = ex_nyc[ex_nyc[&#39;year&#39;] == 2020] . . Testing the chart - . # collapse_show excess_deaths_chart = alt.Chart(ex_nyc).mark_bar(width=5).encode( x=&#39;week:N&#39;, y=&#39;excess_deaths:Q&#39;, color = alt.condition(alt.datum.excess_deaths&gt;0, alt.value(&#39;orange&#39;), alt.value(&#39;steelblue&#39;)) ).properties(height=500, width=alt.Step(10)) . . excess_deaths_chart . This was the easy part and we can see that we are following the trends properly by comparing it with the NYT chart - . There are some differences, which I think is due to the fact that the dataset provided by NYT is actually slightly different than the data they have used to plot. Also there is actually more data used in the article than there is in the GitHub repo. So to make the charts look completely similar we will have to dig in the CDC dataset - which we will ignore for now. . Now we will transform the COVID-19 deaths data to weekly deaths data . ny_co_df = co_df[co_df[&#39;county&#39;] == &#39;New York City&#39;] ny_co_df = ny_co_df[(ny_co_df[&#39;date&#39;] &gt; &#39;2020-03-06&#39;) &amp; (ny_co_df[&#39;date&#39;] &lt; &#39;2020-05-17&#39;)] ny_co_df[&#39;death_per_day&#39;] = ny_co_df[&#39;deaths&#39;].diff() ny_co_df = ny_co_df[1:] weekly_cov_death = ny_co_df.groupby(np.arange(len(ny_co_df))//7).sum() weekly_cov_death[&#39;week&#39;] = range(11,21) . Let&#39;s plot it to see if we get the trends right - . # collapse covid_tick_deaths = alt.Chart(weekly_cov_death).mark_tick(thickness=2, color=&#39;red&#39;).encode( x=&#39;week:N&#39;, y=&#39;death_per_day:Q&#39; ) . . excess_deaths_chart + covid_tick_deaths . This looks correct. Let&#39;s beautify a little - . # collapse excess_deaths_chart = alt.Chart(ex_nyc).mark_bar(width=9).encode( x=&#39;week:N&#39;, y=&#39;excess_deaths:Q&#39;, color = alt.condition(alt.datum.excess_deaths&gt;0, alt.value(&#39;#ffab00&#39;), alt.value(&#39;#8FB8BB&#39;)) ).properties(height=500, width=alt.Step(10)) . . (excess_deaths_chart + covid_tick_deaths).configure_view(strokeWidth=0).configure_axis(grid=False) . Lets add a rectangle from March to May to complete our chart . # collapse source = alt.pd.DataFrame([{&#39;start&#39;: 11, &#39;end&#39;: 20}]) rect = alt.Chart(source).mark_rect(opacity=1, fill=&#39;#eee&#39;, xOffset=5, x2Offset=5).encode( x=&#39;start:N&#39;, x2=&#39;end:N&#39; ) . . (rect + excess_deaths_chart + covid_tick_deaths).configure_view(strokeWidth=0).configure_axis(grid=False) . We can see that it captures the trend extremely well and the datapoints are almost exactly the same. . TODO . The rest of the states using the CDC Data .",
            "url": "https://armsp.github.io/covidviz/2020/06/04/Above-Below-Normal.html",
            "relUrl": "/2020/06/04/Above-Below-Normal.html",
            "date": " • Jun 4, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "Tracking the Global Outbreak: Growth Rates",
            "content": "Today we will make the growth rate charts from the NYT article on Tracking the Global Outbreak for all the countries. . . We will use the JHU CSSE dataset since NYT does not provide its own global countries dataset . #hide_output import pandas as pd import altair as alt raw_data_url = &#39;https://raw.githubusercontent.com/CSSEGISandData/COVID-19/master/csse_covid_19_data/csse_covid_19_time_series/time_series_covid19_confirmed_global.csv&#39; raw_df = pd.read_csv(raw_data_url) alt.renderers.set_embed_options(actions=False) . A few important observations - . There are some countries that have data at a finer level like state/county. For those countires we will extract the extract the corresponding rows, sum them up into a single row and transpose it to convert to a dataframe. | Those exceptional countries are &#39;Australia&#39;, &#39;Canada&#39;, &#39;China&#39;, &#39;Denmark&#39;, &#39;France&#39;, &#39;Netherlands&#39;, &#39;United Kingdom&#39; | . Let&#39;s convert the data into the desired long form from the existing wide form. . # collapse long_df = pd.DataFrame() exceptional_countries = [&#39;Australia&#39;, &#39;Canada&#39;, &#39;China&#39;, &#39;Denmark&#39;, &#39;France&#39;, &#39;Netherlands&#39;, &#39;United Kingdom&#39;] country_df_list = [] def extract_country(s): if s[1].strip() not in exceptional_countries: # print(f&quot;{s[1]} - exceptional case&quot;) # else: temp_df = pd.DataFrame(s[4:]) temp_df.columns = [&#39;value&#39;] temp_df[&#39;country&#39;] = s[1] temp_df[&#39;growth&#39;] = temp_df[&#39;value&#39;].diff() temp_df[&#39;growth&#39;][0] = temp_df[&#39;value&#39;].iloc[0] temp_df[&#39;growth&#39;] = temp_df[&#39;growth&#39;].astype(int) temp_df = temp_df.rename_axis(&#39;date&#39;).reset_index() country_df_list.append(temp_df) for country in exceptional_countries: temp_df = pd.DataFrame(raw_df[raw_df[&#39;Country/Region&#39;] == country].iloc[:,4:].sum(axis=0).rename_axis(&#39;date&#39;).reset_index()) temp_df.columns = [&#39;date&#39;,&#39;value&#39;] temp_df[&#39;country&#39;] = country temp_df[&#39;growth&#39;] = temp_df[&#39;value&#39;].diff() temp_df.loc[0, &#39;growth&#39;] = temp_df[&#39;value&#39;].iloc[0] temp_df[&#39;growth&#39;] = temp_df[&#39;growth&#39;].astype(int) country_df_list.append(temp_df) raw_df.apply(extract_country, axis=1) long_df = pd.concat(country_df_list) . . Beacause this is a large dataset, Altair will - by default - refuse to display because of possible memory issues. So we will have to enable the json transformer so that the data is passed insternally as a url. We enable it using alt.data_transformers.enable(&#39;json&#39;). Do this if you are running it locally. To do the same on Fastpages, I have already uploaded the json file that is generated by Altair behind the scenes and and I will pass the url of the file to the chart so that the output visualization is seen on the website. . # collapse #alt.data_transformers.enable(&#39;json&#39;) # use this if running locally #alt.data_transformers.disable_max_rows() # avoid this as it can hang your system url = &#39;https://raw.githubusercontent.com/armsp/covidviz/master/assets/2020-06-02-Data.json&#39; #comment this when running locally otherwise you will have old data till 1st June only a = alt.Chart().mark_bar(size=2, opacity=0.2, color=&#39;gray&#39;).transform_window( rolling_mean = &#39;mean(growth)&#39;, frame=[-6, 0], groupby=[&#39;place&#39;] ).encode( x=alt.X(&#39;date:T&#39;, title=None), y=alt.Y(&quot;growth:Q&quot;, title=None), ).properties(width=90, height=100) b = alt.Chart().mark_area(fill=&#39;red&#39;, fillOpacity=0.4).transform_window( rolling_mean = &#39;mean(growth)&#39;, frame=[-6, 0], groupby=[&#39;place&#39;] ).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&quot;rolling_mean:Q&quot;,title=&#39;cases&#39;) ) c = b.mark_line(**{&quot;color&quot;: &quot;red&quot;, &quot;opacity&quot;: 0.7, &quot;strokeWidth&quot;: 2}) alt.layer(a, c, data=url).facet(alt.Column(&#39;country:N&#39;, title=None, sort=alt.EncodingSortField(&#39;value&#39;, op=&#39;max&#39;, order=&#39;descending&#39;), header=alt.Header(labelFontSize=13, labelColor=&#39;gray&#39;, labelFontWeight=&#39;bolder&#39;, labelAlign=&#39;center&#39;, labelAnchor=&#39;middle&#39;, labelOrient=&#39;top&#39;, labelPadding=-15, labelAngle=0)), spacing=alt.RowColnumber(row=70, column=0), title=&quot;Countrywise Distribution of Growth, Averaged over 7 days&quot;, columns=7, ).configure_axis( grid=False, #domainWidth=0.1 ).configure_view(strokeWidth=0).configure_title( fontSize=25, font=&#39;Courier&#39;, anchor=&#39;middle&#39;, color=&#39;gray&#39;, dy=-30 ) . . There are a few issues with the above chart - . We are seeing negative values in growth rate, How can it be negative? The lowest it can go is 0. | The graphs for countries with very few cases don&#39;t look good. | The scales of the countries vary a lot. We need to adjust the scale like NYT does, to make it readable. | . Let&#39;s improve upon the issues above with the following solutions - . NYT does not show graphs for those with fewer than 100 cases. Like NYT we have filtered countries with less than 100 cases | The growth rates will be negative if there are discrepancies in the data - when the cumulative cases drop for any reason than the previous day. You will certainly notice thos in the dataset for some of the countries. | We will filter the negative values as based on my observation that&#39;s what NYT seems to be doing | Independednt Y axis | . Few points to keep in mind - . The bar chart shows the increment in cases per day | The line chart is the 7 day average of growth in cases per day | The facet is ordered in descending order by the maximum number of cases | We will forcefully align the countries one below the other because choosing independent axes often leads to misaligned facet items | . # collapse a = alt.Chart().mark_bar(size=2, opacity=0.05, color=&#39;red&#39;).transform_filter( alt.datum.growth &gt;= 0).transform_filter(alt.datum.value &gt; 100).transform_window( rolling_mean = &#39;mean(growth)&#39;, frame=[-6, 0], groupby=[&#39;place&#39;] ).encode( x=alt.X(&#39;date:T&#39;, title=None), y=alt.Y(&quot;growth:Q&quot;, title=None), ).properties(width=90, height=100) b = alt.Chart().mark_area(fill=&#39;red&#39;, fillOpacity=0.04).transform_filter( alt.datum.growth &gt;= 0).transform_filter(alt.datum.value &gt; 100).transform_window( rolling_mean = &#39;mean(growth)&#39;, frame=[-6, 0], groupby=[&#39;place&#39;] ).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&quot;rolling_mean:Q&quot;,title=&#39;cases&#39;) ) c = b.mark_line(**{&quot;color&quot;: &quot;red&quot;, &quot;opacity&quot;: 0.7, &quot;strokeWidth&quot;: 2}) alt.layer(a, b, c, data=url).facet(alt.Column(&#39;country:N&#39;, title=None, sort=alt.EncodingSortField(&#39;value&#39;, op=&#39;max&#39;, order=&#39;descending&#39;), header=alt.Header(labelFontSize=13, labelColor=&#39;gray&#39;, labelFontWeight=&#39;bolder&#39;, labelAlign=&#39;center&#39;, labelAnchor=&#39;middle&#39;, labelOrient=&#39;top&#39;, labelPadding=-15, labelAngle=0)), spacing=alt.RowColnumber(row=70, column=5), title=&quot;Countrywise Distribution of Growth, Averaged over 7 days&quot;, columns=7, align=&#39;each&#39;, ).resolve_scale(y=&#39;independent&#39;, x=&#39;independent&#39;,).configure_axis( grid=False, #domainWidth=0.1 ).configure_view(strokeWidth=0).configure_title( fontSize=25, font=&#39;Courier&#39;, anchor=&#39;middle&#39;, color=&#39;gray&#39;, dy=-30 ) . . Feel free to comment below if you didn&#39;t understand anything and I will try my best to answer .",
            "url": "https://armsp.github.io/covidviz/2020/06/02/World-Map-growth.html",
            "relUrl": "/2020/06/02/World-Map-growth.html",
            "date": " • Jun 2, 2020"
        }
        
    
  
    
        ,"post5": {
            "title": "Missing Deaths",
            "content": "Today we will make the following graph that shows the excess deaths as appeared in the article 87,000 Missing Deaths: Tracking the True Toll of the Coronavirus Outbreak . . Fortunately the NYT provides the dataset for this in their repository. . What does Excess Death mean and how do we calculate it? . Excess deaths are estimates that include deaths from Covid-19 and other causes. Reported Covid-19 deaths reflect official coronavirus deaths during the period when all-cause mortality data is available, including figures that were later revised. . According to the github repository - . Official Covid-19 death tolls offer a limited view of the impact of the outbreak because they often exclude people who have not been tested and those who died at home. All-cause mortality is widely used by demographers and other researchers to understand the full impact of deadly events, including epidemics, wars and natural disasters. The totals in this data include deaths from Covid-19 as well as those from other causes, likely including people who could not be treated or did not seek treatment for other conditions. . . Expected Deaths . We have calculated an average number of expected deaths for each area based on historical data for the same time of year. These expected deaths are the basis for our excess death calculations, which estimate how many more people have died this year than in an average year. . The number of years used in the historical averages changes depending on what data is available, whether it is reliable and underlying demographic changes. The baselines do not adjust for changes in age or other demographics, and they do not account for changes in total population. . The number of expected deaths are not adjusted for how non-Covid-19 deaths may change during the outbreak, which will take some time to figure out. As countries impose control measures, deaths from causes like road accidents and homicides may decline. And people who die from Covid-19 cannot die later from other causes, which may reduce other causes of death. Both of these factors, if they play a role, would lead these baselines to understate, rather than overstate, the number of excess deaths. . That is what we are going to do, average the results based on the baseline field to show the blue line for expected deaths. However it also looks like they are using some sort of linear model and smoothing as mentioned in the accompanying news article - . To estimate expected deaths, we fit a linear model to reported deaths in each country from 2015 to January 2020. The model has two components — a linear time trend to account for demographic changes and a smoothing spline to account for seasonal variation. For countries limited to monthly data, the model includes month as a fixed effect rather than using a smoothing spline. . Since there isn&#39;t much information on that we will ignore it for the time being. . What&#39;s the insight that this data gives? . These numbers undermine the notion that many people who have died from the virus may soon have died anyway. In Britain, which has recorded more Covid-19 deaths than any country except the United States, 59,000 more people than usual have died since mid-March — and about 14,000 more than have been captured by official death statistics. . import pandas as pd import altair as alt url = &quot;https://raw.githubusercontent.com/nytimes/covid-19-data/master/excess-deaths/deaths.csv&quot; raw = pd.read_csv(url) . Lets study Sweden, Switzerland, UK and France for our charts . sweden = raw[raw[&#39;country&#39;] == &quot;Sweden&quot;] switzerland = raw[raw[&#39;country&#39;] == &quot;Switzerland&quot;] uk = raw[raw[&#39;country&#39;] == &quot;United Kingdom&quot;] france = raw[raw[&#39;country&#39;] == &quot;France&quot;] . Let&#39;s start with a simple layered chart - area for year 2019 and line for 2020. We will not average anything right now nor will we use all the fields in our dataset. . base = alt.Chart(sweden).encode( x=alt.X(&#39;week&#39;) ) alt.layer( base.mark_area(fill=&#39;lightblue&#39;, line=True, fillOpacity=0.3).transform_filter(&quot;datum.year == 2019&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&#39;maroon&#39;).transform_filter(&quot;datum.year == 2020&quot;).encode(y=&#39;deaths&#39;), ).properties(width=500) . For Sweden they plot the gray lines for years 2015 to 2019. The blue line is the weekly average per year and the maroon line is the deaths in 2020. . # collapse base = alt.Chart(sweden).encode( x=&#39;week&#39;, ).properties(height=200) lines = alt.layer( base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2015&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2016&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2017&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2018&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2019&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&#39;maroon&#39;).transform_filter(&quot;datum.year == 2020&quot;).encode(y=&#39;deaths&#39;), ).properties(width=400) avg = base.mark_area(fill=&#39;lightblue&#39;, line=True, fillOpacity=0.3).transform_filter(&quot;datum.year &lt; 2020&quot;).encode( y=&#39;average(deaths)&#39;, ).properties(width=500) avg + lines . . Looks like we capture the trend pretty well . Similarly for Switzerland, we will also turn off the grid and the view box - . # collapse base = alt.Chart(switzerland).encode( x=&#39;week&#39;, ).properties(height=300, width=500) lines = alt.layer( base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2015&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2016&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2017&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2018&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2019&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&#39;maroon&#39;).transform_filter(&quot;datum.year == 2020&quot;).encode(y=&#39;deaths&#39;), ).properties(width=400) avg = base.mark_area(fill=&#39;lightblue&#39;, line=True, fillOpacity=0.3).transform_filter(&quot;datum.year &lt; 2020&quot;).encode( y=&#39;average(deaths)&#39;, ) (avg+lines).configure_view(strokeWidth=0).configure_axis(grid=False) . . Trying the same for U.K - . # collapse base = alt.Chart(uk).encode( x=&#39;week&#39;, ).properties(height=300, width=550) l = alt.layer( base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2015&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2016&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2017&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2018&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(&quot;datum.year == 2019&quot;).encode(y=&#39;deaths&#39;), base.mark_line(color=&#39;maroon&#39;).transform_filter(&quot;datum.year == 2020&quot;).encode(y=&#39;deaths&#39;), ).properties(width=400) rule = base.mark_area(fill=&#39;lightblue&#39;, line=True, fillOpacity=0.3).transform_filter(&quot;datum.year &lt; 2020&quot;).encode( y=&#39;average(deaths)&#39;, ) (rule+l).configure_view(strokeWidth=0).configure_axis(grid=False) . . Let&#39;s make use of loops to do the same but for France (based on observation it looks like the gray lines are from 2015 to 2019) - . # collapse base = alt.Chart(france).encode( x=&#39;week&#39;, ).properties(height=300, width=550) avg = base.mark_area(fill=&#39;lightblue&#39;, line=True, fillOpacity=0.3).transform_filter(&quot;datum.year &lt; 2020&quot;).encode( y=&#39;average(deaths)&#39;, ) layer = [] for year in range(2015, 2021): l = base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(f&quot;datum.year == {year}&quot;).encode(y=&#39;deaths&#39;) if year == 2020: l = base.mark_line(color=&#39;maroon&#39;).transform_filter(f&quot;datum.year == {year}&quot;).encode(y=&#39;deaths&#39;) layer.append(l) alt.layer(avg,*layer).configure_view(strokeWidth=0).configure_axis(grid=False) . . The excess deaths articles and graphs update frequently and the graphics also changes quite a bit - . . In the latest versions of the charts they started using dashed lines, for that we will use strokeDash = alt.value([3,3]) . # collapse base = alt.Chart(france).encode( x=&#39;week&#39;, ).properties(height=300, width=550) avg = base.mark_area(fill=&#39;lightblue&#39;, line=True, strokeDash=[1,2], fillOpacity=0.3).transform_filter(&quot;datum.year &lt; 2020&quot;).encode( y=&#39;average(deaths)&#39;, strokeDash = alt.value([3,3]) ) layer = [] for year in range(2015, 2021): l = base.mark_line(color=&quot;gray&quot;, strokeWidth=0.5).transform_filter(f&quot;datum.year == {year}&quot;).encode(y=&#39;deaths&#39;) if year == 2020: l = base.mark_line(color=&#39;maroon&#39;).transform_filter(f&quot;datum.year == {year}&quot;).encode(y=&#39;deaths&#39;) layer.append(l) alt.layer(avg,*layer).configure_view(strokeWidth=0).configure_axis(grid=False) . .",
            "url": "https://armsp.github.io/covidviz/2020/06/01/Excess-Deaths.html",
            "relUrl": "/2020/06/01/Excess-Deaths.html",
            "date": " • Jun 1, 2020"
        }
        
    
  
    
        ,"post6": {
            "title": "Covid Death Rates Graph",
            "content": "The graph that we will learn to make today is from the NYT article on Comparing Coronavirus Death Rates Across the U.S . . import altair as alt import pandas as pd url = &quot;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us-states.csv&quot; usdf = pd.read_csv(url) nydf = usdf[(usdf[&#39;state&#39;] == &quot;New York&quot;) &amp; (usdf[&#39;date&#39;] &lt; &#39;2020-04-23&#39;)] nydf[&#39;deaths_perday&#39;] = nydf[&#39;deaths&#39;].diff() chart = alt.Chart(nydf).mark_area(fill=&#39;red&#39;, fillOpacity=0.5, line=True, interpolate=&#39;step-after&#39;,).encode( x=&#39;date:T&#39;, y=&#39;deaths_perday:Q&#39;, color=alt.value(&#39;red&#39;) # Exceptional Case, bug in Vega or Vega Lite - https://stackoverflow.com/questions/62005052/how-do-i-change-the-line-color-in-altairs-filled-step-chart ).properties(height=250, width=700).configure_view( strokeWidth=0 ).configure_axis( grid=False, title=None ) chart . To highlight the region after the Stay at Home order date, we will use a Rectangle Chart - mark_react() We will also make a new source data that contains the starting date of the stay at home order and the perhaps the end date of stay at home or just the latest data in the dataset. NYT has not updated this graph and has data only till 21st or 22nd April. . # collapse chart = alt.Chart(nydf).mark_area(fill=&#39;red&#39;, fillOpacity=0.5, line=True, interpolate=&#39;step-after&#39;,).encode( x=&#39;date:T&#39;, y=&#39;deaths_perday:Q&#39;, color=alt.value(&#39;red&#39;) # Exceptional Case, bug in Vega or Vega Lite - https://stackoverflow.com/questions/62005052/how-do-i-change-the-line-color-in-altairs-filled-step-chart ).properties(height=250, width=700) . . This is the important piece of code on how to set up the Rectangle chart . source2 = [{ &quot;start&quot;: &quot;2020-03-23&quot;, &quot;end&quot;: nydf[&#39;date&#39;].max(), &quot;event&quot;: &quot;Stay at Home&quot; }] source2 = alt.pd.DataFrame(source2) rect = alt.Chart(source2).mark_rect().encode( x = &#39;start:T&#39;, x2 = &#39;end:T&#39;, color=alt.value(&#39;lightgray&#39;) ) (rect+chart).configure_view( strokeWidth=0 ).configure_axis( grid=False, title=None ) . Similarly you can do the same for any other state. Lets try Michigan for a change - . michdf = usdf[(usdf[&#39;state&#39;] == &quot;Michigan&quot;) &amp; (usdf[&#39;date&#39;] &lt; &#39;2020-04-23&#39;)] michdf[&#39;deaths_perday&#39;] = michdf[&#39;deaths&#39;].diff() . # collapse chart = alt.Chart(michdf).mark_area(fill=&#39;red&#39;, fillOpacity=0.5, line=True, interpolate=&#39;step-after&#39;,).encode( x=&#39;date:T&#39;, y=&#39;deaths_perday:Q&#39;, color=alt.value(&#39;red&#39;) # Exceptional Case, bug in Vega or Vega Lite - https://stackoverflow.com/questions/62005052/how-do-i-change-the-line-color-in-altairs-filled-step-chart ).properties(height=150, width=700) source2 = [{ &quot;start&quot;: &quot;2020-03-25&quot;, &quot;end&quot;: michdf[&#39;date&#39;].max(), &quot;event&quot;: &quot;Stay at Home&quot; }] source2 = alt.pd.DataFrame(source2) rect = alt.Chart(source2).mark_rect().encode( x = &#39;start:T&#39;, x2 = &#39;end:T&#39;, color=alt.value(&#39;lightgray&#39;) ) (rect+chart).configure_view( strokeWidth=0 ).configure_axis( grid=False, title=None ) . . The visualization till the latest date for NY would look like the following - . # collapse nydf = usdf[(usdf[&#39;state&#39;] == &quot;New York&quot;)] nydf[&#39;deaths_perday&#39;] = nydf[&#39;deaths&#39;].diff() chart = alt.Chart(nydf).mark_area(fill=&#39;red&#39;, fillOpacity=0.5, line=True, interpolate=&#39;step-after&#39;,).encode( x=&#39;date:T&#39;, y=&#39;deaths_perday:Q&#39;, color=alt.value(&#39;red&#39;) # Exceptional Case, bug in Vega or Vega Lite - https://stackoverflow.com/questions/62005052/how-do-i-change-the-line-color-in-altairs-filled-step-chart ).properties(height=250, width=700) source2 = [{ &quot;start&quot;: &quot;2020-03-23&quot;, &quot;end&quot;: nydf[&#39;date&#39;].max(), &quot;event&quot;: &quot;Stay at Home&quot; }] source2 = alt.pd.DataFrame(source2) rect = alt.Chart(source2).mark_rect().encode( x = &#39;start:T&#39;, x2 = &#39;end:T&#39;, color=alt.value(&#39;lightgray&#39;) ) (rect+chart).configure_view( strokeWidth=0 ).configure_axis( grid=False, title=None ) . . TODO . Facet for all the states .",
            "url": "https://armsp.github.io/covidviz/2020/05/31/Covid-Death-Rates.html",
            "relUrl": "/2020/05/31/Covid-Death-Rates.html",
            "date": " • May 31, 2020"
        }
        
    
  
    
        ,"post7": {
            "title": "Covid Cases & Deaths Graph for U.S",
            "content": "The graph that we will learn to make today is from the NYT article on Coronavirus in the U.S . . import altair as alt import pandas as pd url = &quot;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us.csv&quot; usdf = pd.read_csv(url) alt.renderers.set_embed_options(actions=False) usdf[&#39;new_deaths&#39;] = usdf[&#39;deaths&#39;].diff() usdf[&#39;new_cases&#39;] = usdf[&#39;cases&#39;].diff() # Bar Chart bar = alt.Chart().mark_bar(size=5,opacity=0.2,color=&#39;gray&#39;).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&#39;new_deaths:Q&#39;) ) # Area Chart area = alt.Chart().mark_area(fill=&#39;gray&#39;, fillOpacity=0.15).transform_window( rolling_average=&#39;mean(new_deaths)&#39;, frame=[-6,0] # NYT uses [-6,0] for their average NOT [-7,0] ).encode( x=&#39;date:T&#39;, y=&#39;rolling_average:Q&#39; ) # Line Chart line = area.mark_line(**{&quot;color&quot;: &quot;black&quot;, &quot;opacity&quot;: 0.7, &quot;strokeWidth&quot;: 3}) # Chart of deaths deaths = (bar+area+line).properties(width=800, title=&quot;Deaths&quot;) # Bar Chart bar2 = alt.Chart().mark_bar(size=5,opacity=0.2,color=&#39;red&#39;).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&#39;new_cases:Q&#39;) ) # Area Chart area2 = alt.Chart().mark_area(fill=&#39;red&#39;, fillOpacity=0.15).transform_window( rolling_average=&#39;mean(new_cases)&#39;, frame=[-6,0] # NYT uses [-6,0] for their average NOT [-7,0] ).encode( x=&#39;date:T&#39;, y=&#39;rolling_average:Q&#39; ) # Line Chart line2 = area2.mark_line(**{&quot;color&quot;: &quot;red&quot;, &quot;opacity&quot;: 0.7, &quot;strokeWidth&quot;: 3}) cases = (bar2+area2+line2).properties(width=800, title=&quot;Cases&quot;) # Vertically concatenate the charts alt.vconcat(cases, deaths, data=usdf).configure_axis( grid=False, title=None ).configure_view( strokeWidth=0 ) . Possible other ways to do this - . Repeat Chart | Facet Chart https://altair-viz.github.io/user_guide/compound_charts.html | .",
            "url": "https://armsp.github.io/covidviz/2020/05/30/Covid-Cases-&-Deaths-in-US.html",
            "relUrl": "/2020/05/30/Covid-Cases-&-Deaths-in-US.html",
            "date": " • May 30, 2020"
        }
        
    
  
    
        ,"post8": {
            "title": "Covid Cases Graph",
            "content": "The graph that we will learn to make today is from the NYT article on Coronavirus Tracking in US which looks as follows - . . We will take the data from NYT&#39;s GitHub repo itself. Lets jump straight into the code - . import altair as alt import pandas as pd alt.renderers.set_embed_options(actions=False) url = &quot;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us.csv&quot; usdf = pd.read_csv(url) usdf[&#39;new_cases&#39;] = usdf[&#39;cases&#39;].diff() # Bar Chart bar = alt.Chart(usdf).mark_bar(size=7,opacity=0.2,color=&#39;red&#39;).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&#39;new_cases:Q&#39;) ) # Area Chart area = alt.Chart(usdf).mark_area(fill=&#39;red&#39;, fillOpacity=0.15).transform_window( rolling_average=&#39;mean(new_cases)&#39;, frame=[-6,0] # NYT uses [-6,0] for their average NOT [-7,0] ).encode( x=&#39;date:T&#39;, y=&#39;rolling_average:Q&#39; ) # Line Chart line = area.mark_line(**{&quot;color&quot;: &#39;#c11111&#39;, &quot;opacity&quot;: 0.9, &quot;strokeWidth&quot;: 5}) chart = (bar+area+line).configure_axis( grid=False, title=None ).configure_view( strokeWidth=0 ).properties(width=1000) chart . Now that we have replicated the chart effectively, lets filter the data so that we drop all the data before March as the chart from NYT shows - . That can be done in 2 ways : . using Pandas | using transform_filter on date | . You guessed it, we will use the latter. The code relevant to this would then be - . transform_filter(alt.datum.date &gt; alt.expr.toDate(&#39;2020-03-01&#39;)) . #collapse import altair as alt import pandas as pd url = &quot;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us.csv&quot; usdf = pd.read_csv(url) #print(udf.columns) usdf[&#39;new_cases&#39;] = usdf[&#39;cases&#39;].diff() # Bar Chart bar = alt.Chart(usdf).mark_bar(size=7,opacity=0.15,color=&#39;red&#39;).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&#39;new_cases:Q&#39;) ).transform_filter(alt.datum.date &gt; alt.expr.toDate(&#39;2020-03-01&#39;)) # Area Chart area = alt.Chart(usdf).mark_area(fill=&#39;red&#39;, fillOpacity=0.1).transform_window( #stroke=&#39;red&#39;, strokeWidth=2 rolling_average=&#39;mean(new_cases)&#39;, frame=[-6,0] # NYT uses [-6,0] for their average NOT [-7,0] ).encode( x=&#39;date:T&#39;, y=&#39;rolling_average:Q&#39; ).transform_filter(alt.datum.date &gt; alt.expr.toDate(&#39;2020-03-01&#39;)) # Line Chart line = area.mark_line(**{&quot;color&quot;: &quot;#c11111&quot;, &quot;opacity&quot;: 0.7, &quot;strokeWidth&quot;: 5}) k = (bar+area+line).configure_axis( grid=False, title=None ).configure_view( strokeWidth=0 ).properties(width=700)#width=alt.Step(500) k . . Now today or maybe a couple of days ago, NYT added interactivity to their charts. Lets do that too. The main concept here is using Altair Selections. For that we will use selection_single() on date field and change the opacity of the bars. So the important code pieces are - . single_bar = alt.selection_single(fields=[&#39;date&#39;], on=&#39;mouseover&#39;, empty=&#39;none&#39;) opacity = alt.condition(single_bar, alt.value(0.5), alt.value(0.15)) . #collapse import altair as alt import pandas as pd url = &quot;https://raw.githubusercontent.com/nytimes/covid-19-data/master/us.csv&quot; usdf = pd.read_csv(url) #print(udf.columns) usdf[&#39;new_cases&#39;] = usdf[&#39;cases&#39;].diff() single_bar = alt.selection_single(fields=[&#39;date&#39;], on=&#39;mouseover&#39;, empty=&#39;none&#39;) # Bar Chart bar = alt.Chart(usdf).mark_bar(size=7,opacity=0.15,color=&#39;red&#39;).encode( x=alt.X(&#39;date:T&#39;), y=alt.Y(&#39;new_cases:Q&#39;), opacity= alt.condition(single_bar, alt.value(0.5), alt.value(0.15)) ).add_selection(single_bar).transform_filter(alt.datum.date &gt; alt.expr.toDate(&#39;2020-03-01&#39;)) # Area Chart area = alt.Chart(usdf).mark_area(fill=&#39;red&#39;, fillOpacity=0.1).transform_window( rolling_average=&#39;mean(new_cases)&#39;, frame=[-6,0] # NYT uses [-6,0] for their average NOT [-7,0] ).encode( x=&#39;date:T&#39;, y=&#39;rolling_average:Q&#39; ).transform_filter(alt.datum.date &gt; alt.expr.toDate(&#39;2020-03-01&#39;)) # Line Chart line = area.mark_line(**{&quot;color&quot;: &quot;#c11111&quot;, &quot;opacity&quot;: 0.7, &quot;strokeWidth&quot;: 5}) chart = (bar+area+line).configure_axis( grid=False, title=None ).configure_view( strokeWidth=0 ).properties(width=700) chart . . Isn&#39;t that amazing . TODO . [ ] Adding tooltip/text to interactive bar chart | .",
            "url": "https://armsp.github.io/covidviz/2020/05/29/Covid-cases.html",
            "relUrl": "/2020/05/29/Covid-cases.html",
            "date": " • May 29, 2020"
        }
        
    
  
    
        ,"post9": {
            "title": "What is Altair?",
            "content": "To understand Altair we need to know what is it built on. The following hierarchy enables us to understand that - . D3 | Vega | Vega-Lite | Altair | . Lets start with Vega. . What is Vega? . Vega is a visualization grammar, a declarative language for creating, saving, and sharing interactive visualization designs. With Vega, you can describe the visual appearance and interactive behavior of a visualization in a JSON format, and generate web-based views using Canvas or SVG. . . Note: visualization grammar . Where does D3 fit in here? . To be clear, Vega is not intended as a “replacement” for D3. D3 is intentionally a lower-level library. During the early design of D3, we even referred to it as a “visualization kernel” rather than a “toolkit” or “framework”. In addition to custom design, D3 is intended as a supporting layer for higher-level visualization tools. Vega is one such tool, and Vega uses D3 heavily within its implementation. . Vega provides a higher-level visualization specification language on top of D3. By design, D3 will maintain an “expressivity advantage” and in some cases will be better suited for novel design ideas. On the other hand, we intend Vega to be convenient for a wide range of common yet customizable visualizations. . Now, that we know the top hierarchy, the rest is easy to follow - . Vega-Lite . Vega-Lite is a high-level grammar of interactive graphics. It provides a concise JSON syntax for rapidly generating visualizations to support analysis. Vega-Lite specifications can be compiled to Vega specifications. . . Note: high-level visualization grammar . Vega-Lite is used by some big players - . | | | | | | | | | | | | . Altair . In short, Altair exposes a Python API for building statistical visualizations that follows Vega-Lite syntax. . Altair is a declarative statistical visualization library for Python, based on Vega and Vega-Lite. With Altair, you can spend more time understanding your data and its meaning. . Altair’s API is simple, friendly and consistent and built on top of the powerful Vega-Lite visualization grammar. This elegant simplicity produces beautiful and effective visualizations with a minimal amount of code. . . I do not intend to teach you how to use Altair or Vega Lite. You can do that on your own using the following excellent resources - . Conference Talk by Jake VanderPlas | . Exploratory Data Visualization with Altair | UW Data Viz Curriculum | .",
            "url": "https://armsp.github.io/covidviz/2020/05/28/Altair-Intro.html",
            "relUrl": "/2020/05/28/Altair-Intro.html",
            "date": " • May 28, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "Hi :wave: . My name is Shantam. This blog will contain my attempts to replicate/emulate the visualizations at large media houses, related to COVID-19 pandemic, using open source data &amp; tools. . I am a driven python developer and data scientist. I have worked with Machine Learning and Big Data too. Did I tell you I am a published poet too? . I am available for consulting, collaborations, part time or full time jobs. Let me know if you want to talk. . If you want me to try a specific visualization, do let me know by raising an issue in the GitHub Repository. . My website - www.shantamraj.com . I am working on a project that you should definitely check out - COVID-19 Stories .",
          "url": "https://armsp.github.io/covidviz/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://armsp.github.io/covidviz/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}